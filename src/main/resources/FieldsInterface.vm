#**
 *
 This template generates interface for all the field containers

 It consists of:
 - two getters

 @author Ilja Hämäläinen
 @version 1

*#
package $package;
import javax.annotation.Generated;

/**
 * GENERATED INTERFACE FOR FIELD PROVIDER. DO NOT MODIFY!
 *
 * generated by soap-to-jpa Maven plugin (https://github.com/p-i/soap-to-jpa)
 */
@Generated(value = "net.pibenchmark.SoapToJpaMojo", date = "${generationDate}", comments = "SoapToJpa Maven plugin")
public interface IFieldProvider {

    /**
    * Provides an array of all the fields
    *
    * @return array of all the fields
    */
    java.util.List<String> getAllFileds();

    /**
    * Provides an array of only fields with primitive types
    *
    * @return
    */
    java.util.List<String> getPrimitiveFields();

    /**
     * Provides an array of only fields with complex type
     *
     * @return
     */
    java.util.List<String> getComplexFields();

    /**
     * Collects the list of all the nested fields
     *
     * @return
     */
    IFieldProvider getInstanceOfSubclass(String nestedClassName);

    /**
     * Provides the array of all the pathes, that
     * sould be used in SQ queries. It contains name of simple fields
     * and path for nested complex object IDs.
     *
     * @return String[]
     */
    java.util.List<java.lang.String> getPathes();

    /**
     * Returns the class Simple name (without package) that is used to build an Query (e.g "Projection")
     */
    String getProjectedClassName();

    /**
     * Returns the class Full name (with package)
     */
    String getProjectedFullClassName();

    /**
     * Initiates JPA class and populates it with a data from SOAP object.
     *
     * @param soapStub - SOAP stub. Expected that it should contain only simple data
     */
    IFieldProvider initiateJPA(Object soapStub);

    /**
     * Calls lambda for each subcluss of the JPA object that was created
     * with {@code initiateJPA()} method
     */
    IFieldProvider forEachSubclass(IFunctionLoadInnerClasses lambda);

    /**
     * Build ready JPA object populated with data
     */
    Object build();

    /**
     * Checks whether current object equals to antoher.
     * It checks not the classes itself, but underlying stubs instead
     */
    boolean equalsTo(IFieldProvider another);

    /**
     * Returns TRUE in case if underlying stub class is inner
     */
    boolean isInner();

    /**
     * Returns TRUE in case if underlying stub class contains ident field (default name is "Id",
     * but user can define another name for identification)
     */
    boolean hasIdentField();

    /**
     * Interface for lambda, used to make actual network call for an object
     */
    @FunctionalInterface
    public interface IFunctionLoadInnerClasses {

        /**
         * Prepares remote call to remote server and returns an JPA object
         * populated with simple data
         *
         * @params stubProvider - field provider for the object we are goind to request
         * @params id - identity for this object
         */
        Object load(IFieldProvider stubProvider, long id);
    }
}
