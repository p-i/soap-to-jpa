#**
*
 This template generates Fields class body

 It consists of:
  - fields as constants

 @author Ilja Hämäläinen
 @version 1

*#
#if($isEmbedded)

/**
 * Inner interface ${className}Fields
 **/
public static class ${className}Fields implements ${fieldsPackage}.IFieldProvider {
#else
package ${package};

import ${factoryPackageName}.JPAEntitiesFactory;
import org.apache.commons.lang.reflect.MethodUtils;

import java.lang.reflect.InvocationTargetException;
import java.util.stream.Stream;
import javax.annotation.Generated;
import java.util.Map;

/**
 * GENERATED FIELD PROVIDER CONTENT. DO NOT MODIFY!
 *
 * generated by soap-to-jpa Maven plugin (https://github.com/p-i/soap-to-jpa)
 */
@Generated(value = "net.pibenchmark.SoapToJpaMojo", date = "${generationDate}", comments = "SoapToJpa Maven plugin")
public class ${className}Fields implements ${fieldsPackage}.IFieldProvider {
#end

    private Object soapObject;
    private Object jpaObject;
    private final Map<java.lang.String, Class<? extends ${fieldsPackage}.IFieldProvider>> mapNestedFields;
#*


    The list if constants
*#
#foreach( $field in $mapOfFields.keySet() )
    public static java.lang.String ${field} = "${display.capitalize($mapOfFields.get($field))}";
#end

    /**
     * Array of all the fields in the current class
     */
    public static java.util.List<java.lang.String> ALL = com.google.common.collect.ImmutableList.<java.lang.String>builder()
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
        .add(${field})
#end
    .build();

    /**
     * Array of only primitive fields in the current class
     */
    public static java.util.List<java.lang.String> SIMPLE_FIELDS = com.google.common.collect.ImmutableList.<java.lang.String>builder()
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#if( $primitiveFields.contains($mapOfFields.get($field)) )
        .add(${field})
#end
#end
    .build();

    /**
     * Array of only complex fields in the current class
     */
    public static java.util.List<java.lang.String> COMPLEX_FIELDS = com.google.common.collect.ImmutableList.<java.lang.String>builder()
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#if( !$primitiveFields.contains($mapOfFields.get($field)) )
        .add(${field})
#end
#end
    .build();

    /**
     * Constructor.
     * Initiate map of inner classes
     */
    public ${className}Fields() {
        mapNestedFields = com.google.common.collect.ImmutableMap
            .<java.lang.String, Class<? extends ${fieldsPackage}.IFieldProvider>>builder()
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#set($currentField = ${display.capitalize($mapOfFields.get($field))})
#set($isNotPrimitive = !$primitiveFields.contains($mapOfFields.get($field)) && !$mapOfFieldTypes.get($mapOfFields.get($field)).isArray() )
#set($isInnerClass = $innerClassNames.contains($currentField))
#if($isNotPrimitive)
#if($isInnerClass)
                .put("${currentField}", ${mapOfFieldTypes.get($mapOfFields.get($field)).getOriginalTypeSimpleName()}Fields.class)
#else
#set($fieldProviderFullName = $mapOfFieldFiles.get($mapOfFieldTypes.get($mapOfFields.get($field)).getOriginalTypeName()))
                .put("${currentField}", ${fieldProviderFullName}.class)
#end
#end
#end
            .build();
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public boolean isInner() {
        return ${isInner};
    }

    /**
     * {@inheritDoc}
     *
    */
    @Override
    public boolean hasIdentField() {
        return ${isContainingIdentField};
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getAllFileds() {
        return this.ALL;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getPrimitiveFields() {
        return this.SIMPLE_FIELDS;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getComplexFields() {
        return this.COMPLEX_FIELDS;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.lang.String getProjectedClassName() {
        return "${className}";
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.lang.String getProjectedFullClassName() {
        return "${soapStubClass}";
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${className}Fields initiateJPA(final Object soapStub) {
        this.soapObject = soapObject;
        this.jpaObject = new ${jpaClass}( (${soapStubClass}) soapStub);
        return this;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${className}Fields forEachSubclass(final IFunctionLoadInnerClasses lambda) {
        Stream.of(this.getComplexFields())
            .parallel()
            .forEach((fieldName) -> {
                try {

                    // get inner object by calling getter from SOAP stub
                    final Object subClassObject = MethodUtils.invokeMethod(this.soapObject, "get" + fieldName, new Object[0]);
                    // load JPA using labmda populated with data
                    final ${fieldsPackage}.IFieldProvider fieldProvider = JPAEntitiesFactory.getInstance().create(subClassObject);
                    Object objJPA = lambda.load(fieldProvider, 1L);
                    // set new JPA sub-object to current JPA calling setter
                    MethodUtils.invokeMethod(this.jpaObject, "set" + fieldName, new Object[]{ objJPA });

                } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) {
                    e.printStackTrace();
                }
            });
        return this;
    }


    /**
     * {@inheritDoc}
     *
     */
    @Override
    public Object build() {
        return this.jpaObject;
    }

    /**
     * Collects the list of all the nested fields
     *
     * @return
     */
    @Override
    public ${fieldsPackage}.IFieldProvider getInstanceOfSubclass(java.lang.String nestedClassName) {
        final Class<? extends ${fieldsPackage}.IFieldProvider> aClass = this.mapNestedFields.get(nestedClassName);
        if (null == aClass) {
            throw new RuntimeException("The class with name " + nestedClassName + " was not found in the ${className} class!");
        }
        try {
            return aClass.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getPathes() {
        return com.google.common.collect.ImmutableList.of(
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#set($currentField = ${display.capitalize($mapOfFields.get($field))})
#if( $primitiveFields.contains($mapOfFields.get($field)) )
            "${currentField}"#if($foreach.hasNext), #end

#else
            "${currentField},${innerClassFields.get($currentField)}.${display.capitalize($identField)}"#if($foreach.hasNext), #end

#end
#end
        );
    }


    /**
     * {@inheritDoc}
     *
     */
    @Override
    public boolean equalsTo(${fieldsPackage}.IFieldProvider o) {
        if (this == o) return true;
        if (o == null) return false;
        return this.getProjectedFullClassName().equals(o.getProjectedFullClassName());
    }
#*


    Inner classes
*#
#if(!${innerClasses.isEmpty()})
    #foreach($innerClass in $innerClasses)
        ${innerClass.getSourceCode()} // end of ${innerClass.getClassName()}Fields class
    #end
#end
}