#**
*
 This template generates Fields class body

 It consists of:
  - fields as constants

 @author Ilja Hämäläinen
 @version 1

*#
#if($isEmbedded)

/**
 * Inner interface ${className}Fields
 **/
public static class ${className}Fields implements IFieldProvider {
#else
package ${package};

import ${factoryPackageName}.JPAEntitiesFactory;
import org.apache.commons.lang.reflect.MethodUtils;

import java.lang.reflect.InvocationTargetException;
import java.util.stream.Stream;
import javax.annotation.Generated;
import java.util.Map;

/**
 * GENERATED JPA CONTENT. DO NOT MODIFY!
 *
 * generated by soap-to-jpa Maven plugin (https://github.com/p-i/soap-to-jpa)
 */
@Generated(value = "net.pibenchmark.SoapToJpaMojo", date = "${generationDate}", comments = "SoapToJpa Maven plugin")
public class ${className}Fields implements ${package}.IFieldProvider {
#end

    private Object soapObject;
    private Object jpaObject;
    private final Map<String, Class<? extends ${package}.IFieldProvider>> mapNestedFields;
#*


    The list if constants
*#
#foreach( $field in $mapOfFields.keySet() )
    public static java.lang.String ${field} = "${display.capitalize($mapOfFields.get($field))}";
#end

    /**
     * Array of only complex fields in the current class
     */
    public static java.lang.String[] ALL = {
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
        ${field}#if($foreach.hasNext), #end

#end
    };

    /**
     * Array of only primitive fields in the current class
     */
    public static java.lang.String[] SIMPLE_FIELDS = {
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#if( $primitiveFields.contains($mapOfFields.get($field)) )
        ${field}#if($foreach.hasNext), #end

#end
#end
    };

    /**
     * Array of only complex fields in the current class
     */
    public static java.lang.String[] COMPLEX_FIELDS = {
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#if( !$primitiveFields.contains($mapOfFields.get($field)) )
        ${field}#if($foreach.hasNext), #end

#end
#end
    };

    /**
     * Constructor.
     * Initiate map of inner classes
     */
    public ${className}Fields() {
        mapNestedFields = com.google.common.collect.ImmutableMap
            .<String, Class<? extends ${package}.IFieldProvider>>builder()
#foreach( $field in $innerClassFields.keySet() )
            .put("${field}", #if($innerClassFields.contains($field)) ${innerClassFields.get($field)}Fields.class #else ${field}Fields.class #end)
#end
            .build();
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public String[] getAllFileds() {
        return this.ALL;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public String[] getPrimitiveFields() {
        return this.SIMPLE_FIELDS;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public String[] getComplexFields() {
        return this.COMPLEX_FIELDS;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public String getProjectedClassName() {
        return "${className}";
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${className}Fields initiateJPA(final Object soapStub) {
        this.soapObject = soapObject;
        this.jpaObject = new ${jpaClass}( (${soapStubClass}) soapStub);
        return this;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${className}Fields forEachSubclass(final IFunctionLoadInnerClasses lambda) {
        Stream.of(this.getComplexFields())
            .parallel()
            .forEach((fieldName) -> {
                try {

                    // get inner object by calling getter from SOAP stub
                    final Object subClassObject = MethodUtils.invokeMethod(this.soapObject, "get" + fieldName, new Object[0]);
                    // load JPA using labmda populated with data
                    final IFieldProvider fieldProvider = JPAEntitiesFactory.getInstance().create(subClassObject);
                    Object objJPA = lambda.load(fieldProvider, 1L);
                    // set new JPA sub-object to current JPA calling setter
                    MethodUtils.invokeMethod(this.jpaObject, "set" + fieldName, new Object[]{ objJPA });

                } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) {
                    e.printStackTrace();
                }
            });
        return this;
    }


    /**
     * {@inheritDoc}
     *
     */
    @Override
    public Object build() {
        return this.jpaObject;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getPathes() {
        return com.google.common.collect.ImmutableList.of(
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#set($currentField = ${display.capitalize($mapOfFields.get($field))})
#if( $primitiveFields.contains($mapOfFields.get($field)) )
            "${currentField}"#if($foreach.hasNext), #end

#else
            "${currentField},${innerClassFields.get($currentField)}.${display.capitalize($identField)}"#if($foreach.hasNext), #end

#end
#end
        );
    }
#*


    Inner classes
*#
#if(!${innerClasses.isEmpty()})
    #foreach($innerClass in $innerClasses)
        ${innerClass.getSourceCode()} // end of ${innerClass.getClassName()}Fields class
    #end
#end
}