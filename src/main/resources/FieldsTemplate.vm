#**
*
 This template generates Fields class body

 It consists of:
  - fields as constants

 @author Ilja Hämäläinen
 @version 1

*#
#if($isEmbedded)

/**
 * Inner interface ${className}Fields
 **/
@Configurable
public static class ${className}Fields implements ${fieldsPackage}.IFieldProvider {
#else
package ${package};

import javax.annotation.Generated;
import java.util.Map;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.springframework.beans.factory.annotation.Configurable;

/**
 * GENERATED FIELD PROVIDER CONTENT. DO NOT MODIFY!
 *
 * generated by soap-to-jpa Maven plugin (https://github.com/p-i/soap-to-jpa)
 */
@Configurable
@Generated(value = "net.pibenchmark.SoapToJpaMojo", date = "${generationDate}", comments = "SoapToJpa Maven plugin")
public class ${className}Fields implements ${fieldsPackage}.IFieldProvider {
#end

    @PersistenceContext
    EntityManager em;

    private Object soapObject;
    private ${fieldsPackage}.IJpaStub jpaObject;
    private final Map<java.lang.String, Class<? extends ${fieldsPackage}.IFieldProvider>> mapNestedFields;
    private IFunctionLoadInnerClasses fnOnLookup;
    private IFunctionPersistInnerClass fnOnCreate;

#*


    The list if constants
*#
#foreach( $field in $mapOfFields.keySet() )
    public static java.lang.String ${field} = "${display.capitalize($mapOfFields.get($field))}";
#end

    /**
     * Array of all the fields in the current class
     */
    public static java.util.List<java.lang.String> ALL = com.google.common.collect.ImmutableList.<java.lang.String>builder()
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
        .add(${field})
#end
    .build();

    /**
     * Array of only primitive fields in the current class
     */
    public static java.util.List<java.lang.String> SIMPLE_FIELDS = com.google.common.collect.ImmutableList.<java.lang.String>builder()
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#if( $primitiveFields.contains($mapOfFields.get($field)) )
        .add(${field})
#end
#end
    .build();

    /**
     * Array of only complex fields in the current class
     */
    public static java.util.List<java.lang.String> COMPLEX_FIELDS = com.google.common.collect.ImmutableList.<java.lang.String>builder()
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#if( !$primitiveFields.contains($mapOfFields.get($field)) )
        .add(${field})
#end
#end
    .build();

    /**
     * Constructor.
     * Initiate map of inner classes
     */
    public ${className}Fields() {
        mapNestedFields = com.google.common.collect.ImmutableMap
            .<java.lang.String, Class<? extends ${fieldsPackage}.IFieldProvider>>builder()
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#set($currentField = ${display.capitalize($mapOfFields.get($field))})
#set($isNotPrimitive = !$primitiveFields.contains($mapOfFields.get($field)) && !$mapOfFieldTypes.get($mapOfFields.get($field)).isArray() )
#set($isInnerClass = $innerClassNames.contains($currentField))
#if($isNotPrimitive)
#if($isInnerClass)
                .put("${currentField}", ${mapOfFieldTypes.get($mapOfFields.get($field)).getOriginalTypeSimpleName()}Fields.class)
#else
#set($fieldProviderFullName = $mapOfFieldFiles.get($mapOfFieldTypes.get($mapOfFields.get($field)).getOriginalTypeName()))
                .put("${currentField}", ${fieldProviderFullName}.class)
#end
#end
#end
            .build();
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public boolean isInner() {
        return ${isInner};
    }

    /**
     * {@inheritDoc}
     *
    */
    @Override
    public boolean hasIdentField() {
        return ${hasIdentField};
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getAllFileds() {
        return this.ALL;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getPrimitiveFields() {
        return this.SIMPLE_FIELDS;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getComplexFields() {
        return this.COMPLEX_FIELDS;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.lang.String getProjectedClassName() {
        return "${className}";
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.lang.String getProjectedFullClassName() {
        return "${soapStubClass}";
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${className}Fields initiateJPA(final Object soapStub, java.util.Map<java.lang.String, java.util.Set<${identityFieldType}>> mapAccumulator) {
        this.soapObject = soapStub;
        final ${soapStubClass} stub = (${soapStubClass}) soapStub;

#if($hasIdentField)
#set($capitalizedFieldName = ${display.capitalize($identityFieldName)})
        if(null != stub.get${capitalizedFieldName}()) {
            // try to find this object in database first
#set($stringIdent = "stub.get${capitalizedFieldName}()")
            #parse("ParsedIdentField.vm")
            this.jpaObject = (${jpaClass}) em.find(${jpaClass}.class, stubIdent);
        }
#end
        if (null == this.jpaObject) {
            this.jpaObject = new ${jpaClass}();
        }

        this.jpaObject.populate(soapStub,  mapAccumulator);
        this.jpaObject.setPopulated(true);

        return this;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${className}Fields collectEmptyInstancesTo(java.util.Map<java.lang.String, java.util.Set<${identityFieldType}>> mapAcc) {
        return this;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public Class<?> getStubClass() {
        return ${soapStubClass}.class;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public Class<? extends  ${fieldsPackage}.IJpaStub> getJPAClass() {
        return ${jpaClass}.class;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${className}Fields onLookup(final IFunctionLoadInnerClasses lambda) {
         this.fnOnLookup = lambda;
         return this;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${className}Fields onCreate(final IFunctionPersistInnerClass lambda) {
        this.fnOnCreate = lambda;
        return this;
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    public ${fieldsPackage}.IJpaStub build() {
        return this.jpaObject;
    }

    /**
     * Collects the list of all the nested fields
     *
     * @return
     */
    @Override
    public ${fieldsPackage}.IFieldProvider getInstanceOfSubclass(java.lang.String nestedClassName) {
        final Class<? extends ${fieldsPackage}.IFieldProvider> aClass = this.mapNestedFields.get(nestedClassName);
        if (null == aClass) {
            throw new RuntimeException("The class with name " + nestedClassName + " was not found in the ${className} class!");
        }
        try {
            return aClass.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * {@inheritDoc}
     *
     */
    @Override
    public java.util.List<java.lang.String> getPathes() {
        return com.google.common.collect.ImmutableList.of(
#foreach( $field in $sorter.sort($mapOfFields.keySet()) )
#set($currentField = ${display.capitalize($mapOfFields.get($field))})
#if( $primitiveFields.contains($mapOfFields.get($field)) )
            "${currentField}"#if($foreach.hasNext), #end

#else
            "${currentField},${innerClassFields.get($currentField)}.${display.capitalize($identityFieldName)}"#if($foreach.hasNext), #end

#end
#end
        );
    }


    /**
     * {@inheritDoc}
     *
     */
    @Override
    public boolean equalsTo(${fieldsPackage}.IFieldProvider o) {
        if (this == o) return true;
        if (o == null) return false;
        return this.getProjectedFullClassName().equals(o.getProjectedFullClassName());
    }

#*


    Inner classes
*#
#if(!${innerClasses.isEmpty()})
    #foreach($innerClass in $innerClasses)
        ${innerClass.getSourceCode()} // end of ${innerClass.getClassName()}Fields class
    #end
#end
}