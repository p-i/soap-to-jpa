#**
*
 This template generates a JPA class body.

 It consists of:
  - fields
  - getters/setters
  - constructor(s)
  - inner classes
  - toString()
  - equals()
  - hashCode()

 @author Ilja Hämäläinen
 @version 1

*#
#if($isEmbedded)

    /**
     * Inner class ${className}JPA.
     **/
    @Embeddable
    @Generated(value = "net.pibenchmark.SoapToJpaMojo", date = "${generationDate}", comments = "SoapToJpa Maven plugin")
    public static class ${className}JPA implements Serializable, ${fieldsPackage}.IJpaStub {
#else
package $package;

import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.CascadeType;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.JoinColumn;
import javax.persistence.Transient;
import javax.annotation.Generated;
import java.io.Serializable;

/**
 * GENERATED JPA FACTORY CONTENT. DO NOT MODIFY!
 *
 * generated by soap-to-jpa Maven plugin (https://github.com/p-i/soap-to-jpa)
 */
@Entity
@Table(name = "${tableNamePrefix}_${className}")
@Generated(value = "net.pibenchmark.SoapToJpaMojo", date = "${generationDate}", comments = "SoapToJpa Maven plugin")
public class ${className}JPA implements Serializable, ${fieldsPackage}.IJpaStub {
#end

#if(!${isEmbedded})

    @Id
#if(!${hasIdentField})
    @GeneratedValue(strategy=GenerationType.AUTO)
#end
    @Column(name="_${identityFieldName.toUpperCase()}_${className}")
    private ${identityFieldType} _${identityFieldName};

    public ${identityFieldType} get${display.capitalize($identityFieldName)}() { return this._${identityFieldName}; }
    public void set${display.capitalize($identityFieldName)}(${identityFieldType} id) { this._${identityFieldName} = id; }

    // keeps object status: created/updated
    @Transient
    private boolean isNew;

    @Override
    public boolean isNew() { return isNew; }
    @Override
    public void setNew(boolean isNew) {this.isNew = isNew;}

#else

    @Override public boolean isNew() { return false; }
    @Override public void setNew(boolean isNew) {}
#end

    // keeps number of filled fields
    @Transient
    private int cntInitialized;

    @Override
    public int getInitializedFieldsCount() { return this.cntInitialized; }

#*


    The list if private fields
*#
#foreach( $field in $fieldMap.keySet() )
#if(${fieldMap.get(${field}).isArrayOfComplextType()})
    @OneToMany
    @JoinColumn
#elseif(${fieldMap.get(${field}).isInnerClass()})
    @Embedded
    @Column(name = "${className.toUpperCase()}_${fieldCamelMap.get($field)}", nullable = true)
#elseif(${isEmbedded} && ${fieldMap.get($field).isComplexType()})
    @OneToOne(cascade = CascadeType.ALL)
    //@JoinColumn(name = "${className.toUpperCase()}_${fieldCamelMap.get($field)}")
#elseif(${isEmbedded} && ${fieldMap.get($field).isCollection()})
    @OneToMany(cascade = CascadeType.ALL)
    @JoinColumn
#elseif(${fieldMap.get($field).isComplexType()})
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn
#elseif(${field} != ${identityFieldName})
    @Column(name = "${className.toUpperCase()}_${fieldCamelMap.get($field)}", nullable = true)
#end
#if(${field} != ${identityFieldName})
    private ${fieldMap.get($field).render()}  _${fieldPrefix}${field};
#end
#end

    public ${className}JPA() {}
#*


    Generate few constructors for each SOAP types assigned with this JPA
*#
#foreach( $constructor in $constructors )
    /**
     * Constructor, that restores an instance of ${className}JPA
     * from SOAP stub $constructor
     *
     * @param stub - instance of typeName <code>${constructor}</code>
     */
    public ${className}JPA(${constructor} stub) {
        this(stub,
            (jpaClass, id) -> null,
            (jpaInstance) -> {},
            new java.util.HashMap<java.lang.String, java.util.Set<${identityFieldType}>>() );
        System.out.println(" # Constructor without argument was called for ${package}.${className}");
    }

    /**
     * Constructor, that restores an instance of ${className}JPA
     * from SOAP stub $constructor
     *
     * @param stub - instance of typeName <code>${constructor}</code>
     * @param lmbLoadObject - lambda-function that loads a given object by the ID
     * @param mapAcc - map-accumulator "class name" <==> "set of ID's" that collects all the objects
     *                 with their ID that has all the fields empty except Ident field.
     *                 In the future we can reload data for these objects.
     */
    public ${className}JPA(${constructor} stub,
                           ${fieldsPackage}.IFieldProvider.IFunctionLoadInnerClasses fnLookupObject,
                           ${fieldsPackage}.IFieldProvider.IFunctionPersistInnerClass fnCreateObject,
                           java.util.Map<java.lang.String, java.util.Set<${identityFieldType}>> mapAcc) {

        this.populate(stub, fnLookupObject, fnCreateObject, mapAcc);

#if(!${isEmbedded})
        this.isNew = true;

        // if current object is empty (only "_${identityFieldName}" field has a value), then add it to accumulator map:
        if (this.cntInitialized == 1 && null != this._${identityFieldName}) {
            if (mapAcc.containsKey("${package}.${className}")) {
                java.util.Set<${identityFieldType}> setExistingIds = mapAcc.get("${package}.${className}");
                setExistingIds.add(this._${identityFieldName});
                mapAcc.put("${package}.${className}", setExistingIds);
            }
            else {
                mapAcc.put("${package}.${className}", com.google.common.collect.Sets.newHashSet(this._${identityFieldName}));
            }
        }
#end

    } // end of constructor


#*

    Method "populate" that could be used in constructor and when we update existing

*#
    /**
     *
     * Populate current object from stub.
     *
     */
    @Override
    public int populate(Object stubObject,
                            ${fieldsPackage}.IFieldProvider.IFunctionLoadInnerClasses fnLookupObject,
                            ${fieldsPackage}.IFieldProvider.IFunctionPersistInnerClass fnCreateObject,
                            java.util.Map<java.lang.String, java.util.Set<${identityFieldType}>> mapAcc) {

        // count how many fields are not null
        this.cntInitialized = 0;
        final ${constructor} stub = (${constructor}) stubObject;

#foreach( $field in $fieldMap.keySet() )
#set($currentField = ${fieldMap.get($field)})
#set($capitalizedFieldName = ${display.capitalize($field)})
##
##
##    Instantiate every field regarding its type
##
        if (null != stub.get${capitalizedFieldName}()) {
#if( ${currentField.isShouldBeCasted()} )
            #parse("CastField.vm")
            this.cntInitialized++;
#elseif( ${currentField.isPrimitive()} || ${currentField.isArrayOfPrimitives()})
            this._${fieldPrefix}${field} = stub.get${capitalizedFieldName}();
            this.cntInitialized++;
#elseif( ${currentField.isArrayOfComplextType()} )#*


            Transfer an array to a collection and mark it as "One-to-many"
        *#
        final int _${field}Size = stub.get${capitalizedFieldName}().length;
        this._${fieldPrefix}${field} = com.google.common.collect.Lists.newArrayList();
        for (int i = 0; i < _${field}Size; i++) {
            this._${fieldPrefix}${field}.add( new ${currentField.getTypeName()}(stub.get${capitalizedFieldName}()[i]) );
        }
        this.cntInitialized++;
#elseif( ${currentField.isCollection()} )#*


            Populate the collection in a loop, creating of a new instance on every iteration
        *#
        this._${fieldPrefix}${field} = com.google.common.collect.Lists.newArrayList();
        for (Object obj : stub.get${capitalizedFieldName}()) {
            this._${field}.add( obj);
        }
        this.cntInitialized++;
#elseif(${isEmbedded} && ${fieldMap.get($field).isComplexType()} && ${fieldMap.get($field).hasIdentField()})#*

          For the inner class: try to get object using lambda. Print this code
          only if inner object has Ident (ID or Number) field.

       *#
        if(null != stub.get${capitalizedFieldName}().get${display.capitalize($identityFieldName)}()) {
            // try to find this object in database first
#set($stringIdent = "stub.get${capitalizedFieldName}().get${display.capitalize($identityFieldName)}()")
            #parse("ParsedIdentField.vm")
            this._${fieldPrefix}${field} = (${currentField.getTypeName()}) fnLookupObject.load(${currentField.getTypeName()}.class, stubIdent);
        }
        if (null == this._${fieldPrefix}${field}) {
            // if it doesn't exist, then create and persist a new one
            this._${fieldPrefix}${field} = new ${currentField.getTypeName()}(stub.get${capitalizedFieldName}(), fnLookupObject, fnCreateObject, mapAcc);
            if (null != this._${fieldPrefix}${field}.get${display.capitalize($identityFieldName)}()) fnCreateObject.persist(this._${fieldPrefix}${field});
        }
        else {
            // otherwise populate existing
            this._${fieldPrefix}${field}.populate(stub.get${capitalizedFieldName}(), fnLookupObject, fnCreateObject, mapAcc);
        }
        this.cntInitialized++;
#elseif( ${currentField.isComplexType()} || ${currentField.isInnerClass()} )
            final ${currentField.getTypeName()} obj_${fieldPrefix}${field} = new ${currentField.getTypeName()}(stub.get${capitalizedFieldName}(), fnLookupObject, fnCreateObject, mapAcc);
            if (obj_${fieldPrefix}${field}.getInitializedFieldsCount() > 0) {
                this._${fieldPrefix}${field} = obj_${fieldPrefix}${field};
                this.cntInitialized++;
            }
#end
        }

#end

        return this.cntInitialized;
    }
#end


#if(!${constructors})
    // if there is no constructors available, implement method to keep compilability
    @Override
    public int populate(Object stub,
                        ${fieldsPackage}.IFieldProvider.IFunctionLoadInnerClasses fnLookupObject,
                        ${fieldsPackage}.IFieldProvider.IFunctionPersistInnerClass fnCreateObject,
                        java.util.Map<java.lang.String, java.util.Set<${identityFieldType}>> mapAcc) {
        return 0;
    }
#end
#*

    Getters and setters
*#
#foreach( $field in $fieldMap.keySet() )
#if(${field} != ${identityFieldName})
    ## Getter:
    public ${fieldMap.get($field).render()} get${display.capitalize($field)}() { return this._${fieldPrefix}${field}; }
    ## Setter:
    public void set${display.capitalize($field)}(${fieldMap.get($field).render()} val) { this._${fieldPrefix}${field} = val; }
#end
#end
#*

    Inner classes
*#
#if(!${innerClasses.isEmpty()})
#foreach($innerClass in $innerClasses)
        ${innerClass.getSourceCode()} // end of ${innerClass.getClassName()}JPA class
#end
#end
#*

    toString()
*#

    /**
     * {@inheritDoc}
     *
     * This code requires Guava library.
     */
    @Override
    public java.lang.String toString() {
        return System.getProperty("line.separator")
                + com.google.common.base.Objects.toStringHelper(this)
#if(!${isEmbedded})
                    .add("_${identityFieldName}", this._${identityFieldName})
#end
#foreach( $field in $fieldMap.keySet() )
                    .add("${field}", this._${fieldPrefix}${field})
#end
                    .omitNullValues()
                    .toString();
    }

#*
    hashCode()
*#

    /**
     * {@inheritDoc}
     *
     * This code requires Guava library.
     */
    @Override
    public int hashCode() {
        return com.google.common.base.Objects.hashCode(
#foreach( $field in $fieldMap.keySet() )
            this._${fieldPrefix}${field},
#end
#if(!${isEmbedded})
            this._${identityFieldName},
#end
            31#* just to garantee ability to be compiled *#);
    }

#*
    equals()
*#

    /**
     * {@inheritDoc}
     *
     * This code requires Guava library.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final ${className}JPA that = (${className}JPA) o;

        return true
#if(!${isEmbedded})
            && com.google.common.base.Objects.equal(this._${identityFieldName}, that._${identityFieldName})
#end
#foreach( $field in $fieldMap.keySet() )
            && com.google.common.base.Objects.equal(this._${fieldPrefix}${field}, that._${fieldPrefix}${field})
#end
            ;
    }

}