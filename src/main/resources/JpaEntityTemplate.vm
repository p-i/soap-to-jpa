#**
*
 This template generates a JPA class body.

 It consists of:
  - fields
  - getters/setters
  - constructor(s)
  - inner classes
  - toString()
  - equals()
  - hashCode()

 @author Ilja Hämäläinen
 @version 1

*#
#if($isEmbedded)

/**
 * Inner class ${className}JPA.
 **/
@Embeddable
@Configurable(autowire = Autowire.BY_TYPE, dependencyCheck = false)
@Generated(value = "net.pibenchmark.SoapToJpaMojo", date = "${generationDate}", comments = "SoapToJpa Maven plugin")
public static class ${className}JPA implements Serializable, ${fieldsPackage}.IJpaStub {
#else
package $package;

import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.CascadeType;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.JoinColumn;
import javax.persistence.Transient;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.ElementCollection;
import javax.persistence.CollectionTable;
import javax.persistence.Inheritance;
import javax.persistence.DiscriminatorColumn;
import javax.annotation.Generated;
import java.io.Serializable;

import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.beans.factory.annotation.Autowire;

/**
 * GENERATED JPA FACTORY CONTENT. DO NOT MODIFY!
 *
 * generated by soap-to-jpa Maven plugin (https://github.com/p-i/soap-to-jpa)
 */
@Entity
@Configurable(autowire = Autowire.BY_TYPE, dependencyCheck = false)
@Table(name = "${tableNamePrefix}_${className}")
@Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
@DiscriminatorColumn(name="DCOL", discriminatorType = javax.persistence.DiscriminatorType.STRING)
@Generated(value = "net.pibenchmark.SoapToJpaMojo", date = "${generationDate}", comments = "SoapToJpa Maven plugin")
public class ${className}JPA
    #if(${className.equals("UDSElement")}) extends UDFValueMapping
    #else extends ${parentClass} #end
    implements Serializable, ${fieldsPackage}.IJpaStub {
#end

#if(!${isEmbedded})

#if(!${className.equals("UDSElement")}) #* Hardcoded stuff: don't set ID for UDF realisation *#

#if(!${hasIdentField})
#if(${parentClass.equals("java.lang.Object")})
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name="ID_${identityFieldName.toUpperCase()}")
    protected ${identityFieldType} _${identityFieldName};
    @Override
    public ${identityFieldType} get${display.capitalize($identityFieldName)}() { return this._${identityFieldName}; }
#else
    @Override
    public ${identityFieldType} get${display.capitalize($identityFieldName)}() { return super.get${display.capitalize($identityFieldName)}(); }
#end
#else
    @Id
    @Column(name="ID_${identityFieldName.toUpperCase()}")
    protected ${identityFieldType} _${identityFieldName};

    @Override
    public ${identityFieldType} get${display.capitalize($identityFieldName)}() { return this._${identityFieldName}; }
    public void set${display.capitalize($identityFieldName)}(${identityFieldType} id) { this._${identityFieldName} = id; }
#end
#end

    // keeps object status: empty or filled with data
    @Column(name="IS_POPULATED")
    private boolean isPopulated = false;

    @Override
    public boolean isPopulated() { return isPopulated; }
    @Override
    public void setPopulated(boolean isPopulated) {this.isPopulated = isPopulated;}

#else

    @Override public ${identityFieldType} get${display.capitalize($identityFieldName)}() { return null; }
    @Override public boolean isPopulated() { return false; }
    @Override public void setPopulated(boolean isPopulated) {}
#end

    @Transient
    @PersistenceContext
    transient EntityManager em;

    // keeps number of filled fields
    @Transient
    private int cntInitialized;

    @Override
    public int getInitializedFieldsCount() { return this.cntInitialized; }

#*


    The list if private fields
*#
#foreach( $field in $fieldMap.keySet() )#*


    Annotate field depending on its type
*##if(${fieldMap.get(${field}).isArrayOfComplextType()})
    @OneToMany
    @JoinColumn
#elseif(${fieldMap.get(${field}).isInnerClass()})
    @Embedded
#elseif(${isEmbedded} && ${fieldMap.get($field).isComplexType()})
    @OneToOne
    @JoinColumn(name = "${className.toUpperCase()}_${fieldCamelMap.get($field)}_id")
#elseif(${fieldMap.get($field).isCollection()})
#if(${fieldMap.get($field).isGenericInnerClass()})
    @ElementCollection
    @CollectionTable(name = "${tableNamePrefix}_${className.toUpperCase()}_${fieldCamelMap.get($field)}")
#else
    @OneToMany
    @JoinColumn
#end
#elseif(${fieldMap.get($field).isComplexType()})
    @OneToOne
    @JoinColumn
#elseif(!${field.equalsIgnoreCase($identityFieldName)})
    @Column(name = "${className.toUpperCase()}_${fieldCamelMap.get($field)}", nullable = true)
#end#*


     Declare field depending on its type. Append default value if necessary
*##if(!${field.equalsIgnoreCase($identityFieldName)})
#if( ${className.equals("UDF")} && ${field.equals("content")} )
    // hardcoded stuff
    private java.util.List<UDFValueMapping> _content = com.google.common.collect.Lists.newArrayList();
#elseif(${fieldMap.get($field).isCollection()})
    private ${fieldMap.get($field).render()}  _${fieldPrefix}${field} = com.google.common.collect.Lists.newArrayList();
#elseif(${fieldMap.get(${field}).isInnerClass()})
    private ${fieldMap.get($field).render()}  _${fieldPrefix}${field} = new ${fieldMap.get($field).render()}();
#else
    private ${fieldMap.get($field).render()}  _${fieldPrefix}${field};
#end
#end
#end

    public ${className}JPA() {}


#*

    Method "populate" that could be used in constructor and when we update existing

*#
    /**
     *
     * Populate current object from stub.
     *
     */
    @Override
    @org.springframework.transaction.annotation.Transactional
    public int populate(Object stubObject, java.util.Map<java.lang.String, java.util.Set<${identityFieldType}>> mapAcc) {

        // count how many fields are not null
        this.cntInitialized = 0;
        final ${constructors} stub = (${constructors}) stubObject;

#if(!${isEmbedded} && !${parentClass.equals("java.lang.Object")} && !${className.equals("UDSElement")})
        super.populate(stubObject, mapAcc);
#end

        // initiate all the fields
        #parse("Populate.vm")

#if(!${isEmbedded})

    // if current object is empty (only "_${identityFieldName}" field has a value), then add it to accumulator map:
    if (this.cntInitialized == 1 && null != this._${identityFieldName}) {
        if (mapAcc.containsKey("${package}.${className}")) {
            java.util.Set<${identityFieldType}> setExistingIds = mapAcc.get("${package}.${className}");
            setExistingIds.add(this._${identityFieldName});
            mapAcc.put("${package}.${className}", setExistingIds);
        }
        else {
            mapAcc.put("${package}.${className}", com.google.common.collect.Sets.newHashSet(this._${identityFieldName}));
        }
    }
    else if (this.cntInitialized > 1) {
        this.isPopulated = true;
    }
#end

        return this.cntInitialized;
    }

#*

    Getters and setters
*#
#foreach( $field in $fieldMap.keySet() )
#if( ${className.equals("UDF")} && ${field.equals("content")} )
    public java.util.List<UDFValueMapping> getContent() { return this._content; }
    public void setContent(java.util.List<UDFValueMapping> val) { this._content = val; }
#elseif(!${field.equalsIgnoreCase($identityFieldName)})
    ## Getter:
    public ${fieldMap.get($field).render()} get${display.capitalize($field)}() { return this._${fieldPrefix}${field}; }
    ## Setter:
    public void set${display.capitalize($field)}(${fieldMap.get($field).render()} val) { this._${fieldPrefix}${field} = val; }
#end
#end
#*

    Inner classes
*#
#if(!${innerClasses.isEmpty()})
#foreach($innerClass in $innerClasses)
            ${innerClass.getSourceCode()} // end of ${innerClass.getClassName()}JPA class
#end
#end
#*

    toString()
*#

    /**
     * {@inheritDoc}
     *
     * This code requires Guava library.
     */
    @Override
    public java.lang.String toString() {
        return com.google.common.base.Objects.toStringHelper(this)
#if(!${isEmbedded})
                    .add("_${identityFieldName}", this._${identityFieldName})
#end
#foreach( $field in $fieldMap.keySet() )
#if(!${field.equalsIgnoreCase($identityFieldName)} && !${fieldMap.get($field).isCollection()})
                    .add("${field}", this._${fieldPrefix}${field})
#end
#end
                    .omitNullValues()
                    .toString();
    }
#*
    hashCode()
*#

    /**
     * {@inheritDoc}
     *
     * This code requires Guava library.
     */
    @Override
    public int hashCode() {
        return com.google.common.base.Objects.hashCode(
#foreach( $field in $fieldMap.keySet() )
#if(!${field.equalsIgnoreCase($identityFieldName)})
            this._${fieldPrefix}${field},
#end
#end
#if(!${isEmbedded})
            this._${identityFieldName},
#end
            31#* just to garantee ability to be compiled *#);
    }

#*
    equals()
*#

    /**
     * {@inheritDoc}
     *
     * This code requires Guava library.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final ${className}JPA that = (${className}JPA) o;

        return true
#if(!${isEmbedded})
            && com.google.common.base.Objects.equal(this._${identityFieldName}, that._${identityFieldName})
#end
#foreach( $field in $fieldMap.keySet() )
#if(!${field.equalsIgnoreCase($identityFieldName)})
            && com.google.common.base.Objects.equal(this._${fieldPrefix}${field}, that._${fieldPrefix}${field})
#end
#end
            ;
    }
}